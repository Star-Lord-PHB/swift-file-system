// Benchmark boilerplate generated by Benchmark

import Benchmark
import Foundation
import FileSystem
import SystemPackage



enum Target {
    case data
    case byteBuffer
    case both
    case lab

    var testData: Bool { self == .data || self == .both }
    var testByteBuffer: Bool { self == .byteBuffer || self == .both }
    var lab: Bool { self == .lab }
}



final class MutableBenchmarkState<T> {
    var value: T
    init(_ value: T) {
        self.value = value
    }
}



nonisolated(unsafe) 
let benchmarks = {

    let metrics = [
        .instructions, .cpuTotal, .wallClock, .mallocCountTotal, .peakMemoryResident, 
        .retainCount, .releaseCount,
        // .memoryLeaked,
    ] as [BenchmarkMetric]

    let target: Target = .both

    do {

        Benchmark("Data Initialization", configuration: .init(metrics: metrics, skip: !target.testData)) { benchmark in
            for _ in benchmark.scaledIterations {
                blackHole(Data(count: 1_000_000))
            }
        }

        Benchmark("ByteBuffer Initialization", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { benchmark in
            for _ in benchmark.scaledIterations {
                blackHole(ByteBuffer(count: 1_000_000))
            }
        }

    }

    do {

        let array = [UInt8](repeating: 0, count: 1_000_000)

        Benchmark("Data Initialization with Array", configuration: .init(metrics: metrics, skip: !target.testData)) { [array] benchmark in
            for _ in benchmark.scaledIterations {
                blackHole(Data(array))
            }
        }

        Benchmark("ByteBuffer Initialization with Array", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { [array] benchmark in
            for _ in benchmark.scaledIterations {
                blackHole(ByteBuffer(array))
            }
        }

    }

    do {

        let sequence = sequence(first: 0 as UInt8, next: { $0 &+ 1 }).prefix(1_000_000)

        Benchmark("Data Initialization with Sequence", configuration: .init(metrics: metrics, skip: !target.testData)) { [sequence] benchmark in
            for _ in benchmark.scaledIterations {
                blackHole(Data(sequence))
            }
        }

        Benchmark("ByteBuffer Initialization with Sequence", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { [sequence] benchmark in
            for _ in benchmark.scaledIterations {
                blackHole(ByteBuffer(sequence))
            }
        }

    }


    do {

        Benchmark("Data Append Single", configuration: .init(metrics: metrics, skip: !target.testData)) { benchmark in
            for _ in benchmark.scaledIterations {
                var data = Data()
                benchmark.startMeasurement()
                for byte in 0 ..< 1_000_000 {
                    data.append(UInt8(truncatingIfNeeded: byte))
                }
                benchmark.stopMeasurement()
                blackHole(data)
            }
        }

        Benchmark("ByteBuffer Append Single", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { benchmark in
            for _ in benchmark.scaledIterations {
                var byteBuffer = ByteBuffer()
                benchmark.startMeasurement()
                for byte in 0 ..< 1_000_000 {
                    byteBuffer.append(UInt8(truncatingIfNeeded: byte))
                }
                benchmark.stopMeasurement()
                blackHole(byteBuffer)
            }
        }

    }


    do {

        let bytesToAppend = [UInt8](repeating: 0, count: 1_000)

        Benchmark("Data Append", configuration: .init(metrics: metrics, skip: !target.testData)) { [bytesToAppend] benchmark in
            for _ in benchmark.scaledIterations {
                var data = Data()
                benchmark.startMeasurement()
                for _ in 0 ..< 1_000 {
                    data.append(contentsOf: bytesToAppend)
                }
                benchmark.stopMeasurement()
                blackHole(data)
            }
        }

        Benchmark("ByteBuffer Append", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { [bytesToAppend] benchmark in
            for _ in benchmark.scaledIterations {
                var byteBuffer = ByteBuffer()
                benchmark.startMeasurement()
                for _ in 0 ..< 1_000 {
                    byteBuffer.append(contentsOf: bytesToAppend)
                }
                benchmark.stopMeasurement()
                blackHole(byteBuffer)
            }
        }

    }


    do {

        let bytesToReplace = [UInt8](repeating: 1, count: 1_000_000)

        Benchmark("Data Replace Subrange", configuration: .init(metrics: metrics, skip: !target.testData)) { [bytesToReplace] benchmark in
            for _ in benchmark.scaledIterations {
                var data = Data(count: 1_000_000)
                benchmark.startMeasurement()
                data.replaceSubrange(10_000 ..< 100_000, with: bytesToReplace)
                benchmark.stopMeasurement()
                blackHole(data)
            }
        }

        Benchmark("ByteBuffer Replace Subrange", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { [bytesToReplace] benchmark in
            for _ in benchmark.scaledIterations {
                var byteBuffer = ByteBuffer(count: 1_000_000)
                benchmark.startMeasurement()
                byteBuffer.replaceSubrange(10_000 ..< 100_000, with: bytesToReplace)
                benchmark.stopMeasurement()
                blackHole(byteBuffer)
            }
        }

    }


    do {

        Benchmark("Data Remove Subrange", configuration: .init(metrics: metrics, skip: !target.testData)) { benchmark in
            for _ in benchmark.scaledIterations {
                var data = Data(count: 1_000_000)
                benchmark.startMeasurement()
                data.removeSubrange(10_000 ..< 100_000)
                benchmark.stopMeasurement()
                blackHole(data)
            }
        }

        Benchmark("ByteBuffer Remove Subrange", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { benchmark in
            for _ in benchmark.scaledIterations {
                var byteBuffer = ByteBuffer(count: 1_000_000)
                benchmark.startMeasurement()
                byteBuffer.removeSubrange(10_000 ..< 100_000)
                benchmark.stopMeasurement()
                blackHole(byteBuffer)
            }
        }

    }


    do {

        let size = 1_000_000

        Benchmark("Data Sequential Write", configuration: .init(metrics: metrics, skip: !target.testData)) { benchmark, data in

            for _ in benchmark.scaledIterations {
                for i in 0 ..< data.value.count {
                    data.value[i] = UInt8(truncatingIfNeeded: i)
                }
            }

        } setup: {
            return MutableBenchmarkState(Data(count: size))
        }

        Benchmark("ByteBuffer Sequential Write", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { benchmark, byteBuffer in

            for _ in benchmark.scaledIterations {
                for i in 0 ..< byteBuffer.value.count {
                    byteBuffer.value[i] = UInt8(truncatingIfNeeded: i)
                }
            }

        } setup: {
            return MutableBenchmarkState(ByteBuffer(count: size))
        }

    }


    do {

        let content = sequence(first: 0 as UInt8, next: { $0 &+ 1 }).prefix(1_000_000)

        Benchmark("Data Sequential Read", configuration: .init(metrics: metrics, skip: !target.testData)) { benchmark, data in

            for _ in benchmark.scaledIterations {
                for i in 0 ..< data.count {
                    blackHole(data[i])
                }
            }

        } setup: {
            return Data(content)
        }

        Benchmark("ByteBuffer Sequential Read", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { benchmark, byteBuffer in

            for _ in benchmark.scaledIterations {
                for i in 0 ..< byteBuffer.count {
                    blackHole(byteBuffer[i])
                }
            }

        } setup: {
            return ByteBuffer(content)
        }

    }


    do {

        Benchmark("Data CoW", configuration: .init(metrics: metrics, skip: !target.testData)) { benchmark, data in

            benchmark.startMeasurement()

            for _ in benchmark.scaledIterations {
                var mutableData = data
                mutableData[0] = 0xFF
                blackHole(mutableData)
            }

        } setup: {
            return Data(count: 1_000_000)
        }

        Benchmark("ByteBuffer CoW", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { benchmark, byteBuffer in

            benchmark.startMeasurement()

            for _ in benchmark.scaledIterations {
                var mutableByteBuffer = byteBuffer
                mutableByteBuffer[0] = 0xFF
                blackHole(mutableByteBuffer)
            }

        } setup: {
            return ByteBuffer(count: 1_000_000)
        }

    }


    do {

        Benchmark("Data Self Copy", configuration: .init(metrics: metrics, skip: !target.testData)) { benchmark, data in

            for _ in benchmark.scaledIterations {
                blackHole(Data(data))
            }

        } setup: {
            return Data(count: 1_000_000)
        }

        Benchmark("ByteBuffer Self Copy", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { benchmark, byteBuffer in

            for _ in benchmark.scaledIterations {
                blackHole(ByteBuffer(byteBuffer))
            }

        } setup: {
            return ByteBuffer(count: 1_000_000)
        }

    }


    do {

        Benchmark("Data Slice Copy", configuration: .init(metrics: metrics, skip: !target.testData)) { benchmark, data in

            for _ in benchmark.scaledIterations {
                let slice = data[100_000 ..< 900_000]
                blackHole(Data(slice))
            }

        } setup: {
            return Data(count: 1_000_000)
        }

        Benchmark("ByteBuffer Slice Copy", configuration: .init(metrics: metrics, skip: !target.testByteBuffer)) { benchmark, byteBuffer in

            for _ in benchmark.scaledIterations {
                let slice = byteBuffer[100_000 ..< 900_000]
                blackHole(ByteBuffer(slice))
            }

        } setup: {
            return ByteBuffer(count: 1_000_000)
        }

    }


    do {

        Benchmark("Lab Benchmark", configuration: .init(metrics: metrics, skip: !target.lab)) { benchmark in
            
        }

    }

}